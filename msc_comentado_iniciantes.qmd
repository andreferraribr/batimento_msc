---
title: "Valida√ß√£o da Matriz de Saldos Cont√°beis (MSC)"
subtitle: "Sistema automatizado para valida√ß√£o de dados fiscais"
author: "GEINF"
date: today
execute:
  warning: false
  message: false
  cache: false
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-summary: "Ver c√≥digo"
    fig-width: 12
    fig-height: 8
---

# Introdu√ß√£o ao Projeto

## O que √© a Matriz de Saldos Cont√°beis (MSC)?

A **Matriz de Saldos Cont√°beis (MSC)** √© um arquivo fundamental para a elabora√ß√£o dos relat√≥rios fiscais do governo federal, especificamente:

-   **RREO** (Relat√≥rio Resumido da Execu√ß√£o Or√ßament√°ria)
-   **RGF** (Relat√≥rio de Gest√£o Fiscal)

Este sistema automatiza a valida√ß√£o desses dados, verificando se todos os c√≥digos utilizados est√£o corretos conforme as normas estabelecidas.

## Estrutura dos Dados

A **Matriz de Saldos Cont√°beis (MSC)** possui uma estrutura hier√°rquica com **6 posi√ß√µes de identifica√ß√£o**:

| Posi√ß√£o | Tipos Aceitos | Descri√ß√£o | Exemplo |
|-----------------|--------------------|-----------------|-----------------|
| **1** | PO | Programa Or√ßament√°rio | 10101 |
| **2** | FP, FR | Fun√ß√£o Program√°tica / Fonte de Recursos | 1000 |
| **3** | FR, ND, NR | Fonte / Natureza Despesa / Natureza Receita | 33903016 |
| **4** | FS | Fun√ß√£o Subfun√ß√£o | 07122 |
| **5** | AI, CO | Ano de Inclus√£o / Complemento | 2010, 1001 |
| **6** | CO | Complemento | 1001 |

### Fluxo de Valida√ß√£o

O processo segue esta sequ√™ncia:

1.  **Carregamento** - Arquivo MSC √© lido e processado
2.  **Extra√ß√£o** - As 6 posi√ß√µes de identifica√ß√£o s√£o extra√≠das
3.  **Valida√ß√£o** - C√≥digos s√£o verificados contra portarias e refer√™ncias SIAFI
4.  **Relat√≥rio** - Resultados de conformidade s√£o gerados

### Regras Cr√≠ticas de Valida√ß√£o

-   **C√≥digos Exclu√≠dos**: C√≥digos com `situacao_siconfi = "E"` s√£o **rejeitados**
-   **Anos AI**: Apenas anos entre 2004-2024 s√£o aceitos
-   **Refer√™ncias Ativas**: Apenas c√≥digos ativos do SIAFI s√£o v√°lidos

# Prepara√ß√£o do Ambiente

## Carregamento de Bibliotecas

```{r bibliotecas}
# Bibliotecas para manipula√ß√£o de dados
library(dplyr)      # Manipula√ß√£o de dados (filtros, agrupamentos)
library(tidyr)      # Reorganiza√ß√£o de dados
library(stringr)    # Manipula√ß√£o de texto

# Bibliotecas para leitura de arquivos
library(readxl)     # Ler arquivos Excel (.xlsx)
library(readr)      # Ler arquivos CSV e texto
library(janitor)    # Limpeza de nomes de colunas

# Bibliotecas para an√°lise e visualiza√ß√£o
library(purrr)      # Programa√ß√£o funcional
library(forcats)    # Manipula√ß√£o de fatores
library(DT)         # Tabelas interativas
library(knitr)      # Relat√≥rios
library(kableExtra) # Formata√ß√£o de tabelas
library(scales)     # Formata√ß√£o de n√∫meros
library(glue)       # Formata√ß√£o de texto


```

## Defini√ß√£o de Par√¢metros

```{r parametros}
# Define qual m√™s ser√° analisado
# Formato: YYYYMM (Ano + M√™s com 2 d√≠gitos)
mes <- "202507"  # Julho de 2025

# Monta o nome do arquivo baseado no m√™s
arquivo_msc <- paste0("TG-MSC", mes, ".csv")

cat("Analisando dados do m√™s:", mes)
cat("\nArquivo a ser processado:", arquivo_msc)
```

# Carregamento dos Dados

## Dados da MSC (Matriz de Saldos Cont√°beis)

```{r carregar_msc}
# Carrega o arquivo principal da MSC
# skip = 1: pula a primeira linha (cabe√ßalho especial)
# delim = ";": campos separados por ponto e v√≠rgula
TG_MSC <- read_delim(arquivo_msc, 
                     delim = ";", 
                     escape_double = FALSE, 
                     trim_ws = TRUE, 
                     skip = 1) %>% 
  # Converte a conta para texto (importante para manter zeros √† esquerda)
  mutate(CONTA = as.character(CONTA)) %>% 
  # Padroniza nomes das colunas (min√∫sculas, sem espa√ßos)
  clean_names()

# Mostra informa√ß√µes b√°sicas sobre os dados carregados
# cat("Total de registros carregados:", nrow(TG_MSC))
# cat("\nColunas do arquivo:")
# names(TG_MSC)
```

## Dados das Portarias (Regras de Valida√ß√£o)

```{r carregar_portarias}
# Carrega diferentes abas da planilha de portarias
# Cada aba cont√©m c√≥digos v√°lidos para diferentes tipos

# 1. Programas Or√ßament√°rios (PO)
portaria_PO <- read_excel("portaria.xlsx", sheet = "PO", skip = 4) %>% 
  clean_names()

# 2. Complementos (CO)  
portaria_CO <- read_excel("portaria.xlsx", sheet = "CO", skip = 6) %>% 
  clean_names() %>%
  # Renomeia a primeira coluna para um nome mais claro
  rename(co_siconfi = 1) %>%
  # Filtra apenas linhas que cont√™m n√∫meros (c√≥digos v√°lidos)
  filter(str_detect(co_siconfi, ".*[0-9].*"))

# 3. Layout da MSC (estrutura esperada)
portaria_LAYOUT <- read_excel("portaria.xlsx", sheet = "Leiaute MSC", skip = 3) %>% 
  mutate(CONTA = as.character(CONTA)) %>% 
  clean_names()

cat("Dados das portarias carregados:")
cat("\n- C√≥digos PO:", nrow(portaria_PO))
cat("\n- C√≥digos CO:", nrow(portaria_CO))
cat("\n- Layouts MSC:", nrow(portaria_LAYOUT))
```

## Refer√™ncias do Sistema SIAFI

```{r carregar_referencias}
# Carrega arquivos de refer√™ncia do SIAFI
# Estes arquivos cont√™m c√≥digos v√°lidos para diferentes categorias

# 1. RELNR: Natureza de Receita
# read_fwf: l√™ arquivo de largura fixa (cada coluna tem tamanho fixo)
relnr <- read_fwf("RELNR.TXT", 
                  skip = 10,  # pula linhas de cabe√ßalho
                  col_positions = fwf_positions(
                      start = c(1, 12, 39, 42, 53, 80),    # posi√ß√£o inicial de cada coluna
                      end   = c(10, 38, 41, 50, 78, 82),   # posi√ß√£o final de cada coluna
                      col_names = c("NR_UNIAO", "TITULO_UNIAO", "SITUACAO_UNIAO",
                                    "NR_SICONFI", "TITULO_SICONFI", "SITUACAO_SICONFI")
                  ),
                  locale = locale(encoding = "latin1")) %>%  # codifica√ß√£o de caracteres
  clean_names()

# 2. RELND: Natureza de Despesa
relnd <- read_fwf("RELND.TXT", 
                  skip = 10,  # pula linhas de cabe√ßalho
                  col_positions = fwf_positions(
                      start = c(1, 12, 39, 42, 53, 80),    # posi√ß√£o inicial de cada coluna
                      end   = c(10, 38, 41, 50, 78, 82),   # posi√ß√£o final de cada coluna
                      col_names = c("ND_UNIAO", "TITULO_UNIAO", "SITUACAO_UNIAO",
                                    "ND_SICONFI", "TITULO_SICONFI", "SITUACAO_SICONFI")
                  ),
                  locale = locale(encoding = "latin1")) %>%
  clean_names()

# 3. RELFONT: Fonte de Recursos
relfont <- read_fwf("RELFONT.TXT", 
                    skip = 7,
                    col_positions = fwf_positions(
                        start = c(1, 9, 61, 66),
                        end   = c(8, 58, 65, 68),
                        col_names = c("FR_UNIAO", "TITULO_FR_SICONFI", 
                                      "FR_SICONFI", "SIT")
                    ),
                    locale = locale(encoding = "latin1")) %>%
  clean_names()

cat("Refer√™ncias SIAFI carregadas:")
cat("\n- Natureza Receita (NR):", nrow(relnr))
cat("\n- Natureza Despesa (ND):", nrow(relnd))
cat("\n- Fonte Recursos (FR):", nrow(relfont))
```

# Processamento dos Dados

## Combina√ß√£o dos Dados MSC com Layout

```{r processar_dados}
# Une os dados da MSC com o layout da portaria
# left_join: mant√©m todos os registros da MSC, adicionando info do layout quando dispon√≠vel
tabelao <- left_join(TG_MSC, portaria_LAYOUT, 
                     suffix = c(".msc", ".layout"),  # sufixos para colunas com mesmo nome
                     by = "conta") %>%
  # Corrige problema: colunas 5 e 6 n√£o receberam sufixo autom√°tico
  rename(
    ic5.msc = ic5,      # ic5 vira ic5.msc
    tipo5.msc = tipo5,  # tipo5 vira tipo5.msc
    ic6.msc = ic6,      # ic6 vira ic6.msc
    tipo6.msc = tipo6   # tipo6 vira tipo6.msc
  )

cat("Dados processados:")
cat("\n- Total de registros:", nrow(tabelao))
cat("\n- Total de colunas:", ncol(tabelao))

# Mostra as colunas de identifica√ß√£o (IC) e tipo
colunas_importantes <- names(tabelao)[grepl("ic[1-6]|tipo[1-6]", names(tabelao))]
cat("\n- Colunas de identifica√ß√£o:", length(colunas_importantes))
```

# Sistema de Valida√ß√£o Autom√°tica

## Defini√ß√£o das Fun√ß√µes de Valida√ß√£o

```{r definir_funcoes}
# Anos v√°lidos para AI (Ano de Inclus√£o)
# AI deve estar entre 2004 e 2024
anos_ai_validos <- 2004:2024

# Valores v√°lidos para FP (seguindo a mesma l√≥gica do AI)
valores_fp_validos <- c(1, 2)

# FUN√á√ÉO CR√çTICA: Preparar c√≥digos v√°lidos (excluir c√≥digos com situacao_siconfi = "E")
preparar_codigos_validos <- function() {
  
  cat("Filtrando c√≥digos exclu√≠dos (situacao_siconfi = 'E')...\n")
  
  # NR: Natureza de Receita - apenas c√≥digos ativos (situacao_siconfi != "E")
  nr_validos <- relnr %>%
    filter(is.na(situacao_siconfi) | situacao_siconfi != "E") %>%
    pull(nr_siconfi) %>%
    unique()
  
  # ND: Natureza de Despesa - apenas c√≥digos ativos (situacao_siconfi != "E") 
  nd_validos <- relnd %>%
    filter(is.na(situacao_siconfi) | situacao_siconfi != "E") %>%
    pull(nd_siconfi) %>%
    unique()
  
  # FR: Fonte de Recursos - manter todos (n√£o tem campo situacao)
  fr_validos <- relfont$fr_siconfi %>% unique()
  
  # CO: Complementos - manter todos 
  co_validos <- portaria_CO$co_siconfi %>% unique()
  
  # Contar c√≥digos exclu√≠dos para estat√≠stica
  nr_excluidos <- relnr %>% filter(situacao_siconfi == "E", !is.na(situacao_siconfi)) %>% nrow()
  nd_excluidos <- relnd %>% filter(situacao_siconfi == "E", !is.na(situacao_siconfi)) %>% nrow()
  
  cat("C√≥digos v√°lidos preparados:")
  cat("\n- NR (ativos):", length(nr_validos), "| Exclu√≠dos:", nr_excluidos)
  cat("\n- ND (ativos):", length(nd_validos), "| Exclu√≠dos:", nd_excluidos) 
  cat("\n- FR (todos):", length(fr_validos))
  cat("\n- CO (todos):", length(co_validos))
  cat("\n")
  
  return(list(
    nr_validos = nr_validos,
    nd_validos = nd_validos,
    fr_validos = fr_validos,
    co_validos = co_validos,
    estatisticas = list(nr_excluidos = nr_excluidos, nd_excluidos = nd_excluidos)
  ))
}

# Executar prepara√ß√£o dos c√≥digos v√°lidos
codigos_validos <- preparar_codigos_validos()

# FUN√á√ÉO 1: Agrupa c√≥digos por tipo
# Esta fun√ß√£o encontra todos os c√≥digos de um determinado tipo em todas as posi√ß√µes
agrupar_tipos <- function(tipo) {
  # Busca o tipo em cada posi√ß√£o (2 a 6) e coleta os c√≥digos √∫nicos
  grupo_2 <- tabelao %>% filter(tipo2.msc == tipo, !is.na(ic2.msc)) %>% pull(ic2.msc) %>% unique()
  grupo_3 <- tabelao %>% filter(tipo3.msc == tipo, !is.na(ic3.msc)) %>% pull(ic3.msc) %>% unique()
  grupo_4 <- tabelao %>% filter(tipo4.msc == tipo, !is.na(ic4.msc)) %>% pull(ic4.msc) %>% unique()
  grupo_5 <- tabelao %>% filter(tipo5.msc == tipo, !is.na(ic5.msc)) %>% pull(ic5.msc) %>% unique()
  grupo_6 <- tabelao %>% filter(tipo6.msc == tipo, !is.na(ic6.msc)) %>% pull(ic6.msc) %>% unique()
  
  # Se n√£o encontrou nada, retorna estrutura vazia
  if(length(grupo_2) == 0 && length(grupo_3) == 0 && length(grupo_4) == 0 && 
     length(grupo_5) == 0 && length(grupo_6) == 0) {
    return(data.frame(
      codigo = character(0),
      origem = character(0),
      tipo_filtrado = character(0)
    ))
  }
  
  # Combina todos os grupos em uma tabela
  data.frame(
    codigo = c(grupo_2, grupo_3, grupo_4, grupo_5, grupo_6),
    origem = c(rep("ic2", length(grupo_2)),
               rep("ic3", length(grupo_3)), 
               rep("ic4", length(grupo_4)),
               rep("ic5", length(grupo_5)),
               rep("ic6", length(grupo_6))),
    tipo_filtrado = tipo
  )
}

# FUN√á√ÉO 2: Detecta automaticamente quais tipos existem em cada posi√ß√£o
detectar_tipos_por_posicao <- function(dados) {
  cat("DETECTANDO TIPOS POR POSI√á√ÉO:\n")
  cat("================================\n\n")
  
  tipos_por_posicao <- list()
  
  # Analisa cada posi√ß√£o de 1 a 6
  for(i in 1:6) {
    col_name <- paste0("tipo", i, ".msc")
    
    if(col_name %in% names(dados)) {
      # Encontra tipos √∫nicos (remove NAs)
      tipos_unicos <- dados[[col_name]] %>% 
        .[!is.na(.)] %>% 
        unique() %>% 
        sort()
      
      tipos_por_posicao[[paste0("pos_", i)]] <- tipos_unicos
      
      # Mostra a contagem
     # cat(paste0("POSI√á√ÉO ", i, ":\n"))
      #print(table(dados[[col_name]], useNA = "ifany"))
      #cat("\n")
    }
  }
  
  return(tipos_por_posicao)
}

# FUN√á√ÉO 3: Aplica valida√ß√µes automaticamente 
executar_validacao_automatica <- function(dados) {
  cat("INICIANDO VALIDA√á√ÉO AUTOM√ÅTICA (com filtro de c√≥digos exclu√≠dos)\n")
  cat("==================================================================\n\n")
  
  # Detecta tipos primeiro
  tipos_detectados <- detectar_tipos_por_posicao(dados)
  
  # Aplica valida√ß√µes baseado nos tipos encontrados - USANDO C√ìDIGOS V√ÅLIDOS
  dados_validados <- dados %>%
    mutate(
      # POSI√á√ÉO 1: Somente PO (Programa Or√ßament√°rio)
      posicao_1 = case_when(
        tipo1.msc == "PO" ~ ifelse(ic1.msc %in% portaria_PO$codigo, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      # POSI√á√ÉO 2: FP (sempre OK) ou FR (validar com c√≥digos filtrados)
      posicao_2 = case_when(
        tipo2.msc == "FP" ~ ifelse(ic2.msc %in% valores_fp_validos, "ok", "verificar"),
        tipo2.msc == "FR" ~ ifelse(ic2.msc %in% codigos_validos$fr_validos, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      # POSI√á√ÉO 3: FR, ND ou NR (USANDO C√ìDIGOS FILTRADOS - SEM EXCLU√çDOS)
      posicao_3 = case_when(
        tipo3.msc == "FR" ~ ifelse(ic3.msc %in% codigos_validos$fr_validos, "ok", "verificar"),
        tipo3.msc == "ND" ~ ifelse(ic3.msc %in% codigos_validos$nd_validos, "ok", "verificar"),
        tipo3.msc == "NR" ~ ifelse(ic3.msc %in% codigos_validos$nr_validos, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      # POSI√á√ÉO 4: Somente FS (sempre OK por enquanto)
      posicao_4 = case_when(
        tipo4.msc == "FS" ~ "ok",
        TRUE ~ "demais"
      ),
      
      # POSI√á√ÉO 5: AI (anos 2004-2024) ou CO (c√≥digos v√°lidos)
      posicao_5 = case_when(
        tipo5.msc == "AI" ~ ifelse(ic5.msc %in% anos_ai_validos, "ok", "verificar"),
        tipo5.msc == "CO" ~ ifelse(ic5.msc %in% codigos_validos$co_validos, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      # POSI√á√ÉO 6: Somente CO (c√≥digos v√°lidos)
      posicao_6 = case_when(
        tipo6.msc == "CO" ~ ifelse(ic6.msc %in% codigos_validos$co_validos, "ok", "verificar"),
        TRUE ~ "demais"
      )
    )
  
  # cat("Valida√ß√£o autom√°tica conclu√≠da (c√≥digos exclu√≠dos filtrados)!\n\n")
  
  return(list(
    dados_validados = dados_validados,
    tipos_detectados = tipos_detectados
  ))
}

# FUN√á√ÉO 4: Verifica qualidade dos c√≥digos (VERS√ÉO CORRIGIDA)
verificar_todos_codigos_correto <- function() {
  # Cria tabela com tipos, dados encontrados e refer√™ncias FILTRADAS para comparar
  tribble(
    ~tipo, ~dados, ~referencia,
    "FR", FT_msc, codigos_validos$fr_validos,
    "NR", NR_msc, codigos_validos$nr_validos,
    "ND", ND_msc, codigos_validos$nd_validos,
    "CO", CO_msc, codigos_validos$co_validos,
    "AI", AI_msc, anos_ai_validos,
    "FP", FP_msc, valores_fp_validos
  ) %>%
  mutate(
    # Para cada linha, compara dados com refer√™ncia
    diagnostico = map2(dados, referencia, ~{
      # Se n√£o h√° dados, retorna zeros
      if(nrow(.x) == 0) {
        return(tibble(
          total = 0, encontrados = 0, perdidos = 0, 
          percentual = 0, status = "N/A"
        ))
      }
      
      # Converte c√≥digos para n√∫mero e compara com refer√™ncia FILTRADA
      codigos <- as.numeric(.x$codigo)
      ref_vec <- if(is.data.frame(.y)) .y[[1]] else .y
      
      encontrados_logico <- codigos %in% ref_vec
      encontrados_count <- sum(encontrados_logico, na.rm = TRUE)
      total_count <- length(codigos)
      
      tibble(
        total = total_count,
        encontrados = encontrados_count,
        perdidos = total_count - encontrados_count,
        percentual = round((encontrados_count / total_count) * 100, 1),
        status = if_else((encontrados_count / total_count) >= 0.99, "‚úÖ", "‚ö†Ô∏è")
      )
    })
  ) %>%
  select(-dados, -referencia) %>%
  unnest(diagnostico)
}

cat("Fun√ß√µes de valida√ß√£o definidas com sucesso!")
cat("\nEstat√≠sticas de c√≥digos exclu√≠dos:")
cat("\n- NR exclu√≠dos:", codigos_validos$estatisticas$nr_excluidos)
cat("\n- ND exclu√≠dos:", codigos_validos$estatisticas$nd_excluidos)
```

# Execu√ß√£o da Valida√ß√£o

## An√°lise Autom√°tica dos Tipos

```{r executar_validacao}
# Executa o sistema de valida√ß√£o autom√°tica
resultado <- executar_validacao_automatica(tabelao)

# Separa os resultados
tabelao_validado <- resultado$dados_validados
tipos_encontrados <- resultado$tipos_detectados
```

## Cria√ß√£o dos Grupos de C√≥digos

```{r criar_grupos}
# Cria grupos de c√≥digos para an√°lise posterior
# Cada grupo cont√©m todos os c√≥digos de um tipo espec√≠fico encontrados nos dados

FT_msc <- agrupar_tipos("FR")   # Fonte de Recursos
ND_msc <- agrupar_tipos("ND")   # Natureza de Despesa  
NR_msc <- agrupar_tipos("NR")   # Natureza de Receita
CO_msc <- agrupar_tipos("CO")   # Complementos
AI_msc <- agrupar_tipos("AI")   # Ano de Inclus√£o
FP_msc <- agrupar_tipos("FP")   # Financeiro / Patrimonial

# cat("Grupos de c√≥digos criados:")
# cat("\n- FR (Fonte Recursos):", nrow(FT_msc), "c√≥digos √∫nicos")
# cat("\n- ND (Natureza Despesa):", nrow(ND_msc), "c√≥digos √∫nicos")
# cat("\n- NR (Natureza Receita):", nrow(NR_msc), "c√≥digos √∫nicos")
# cat("\n- CO (Complementos):", nrow(CO_msc), "c√≥digos √∫nicos")
# cat("\n- AI (Ano Inclus√£o):", nrow(AI_msc), "c√≥digos √∫nicos")
# cat("\n- FP (Financeiro / Patrimonial):", nrow(FP_msc), "c√≥digos √∫nicos")
```

# Resultados da Valida√ß√£o

## Verifica√ß√£o da Qualidade dos C√≥digos

```{r verificacao_codigos}
# Executa verifica√ß√£o e mostra resultados em tabela interativa
resultado_verificacao <- verificar_todos_codigos_correto()

datatable(resultado_verificacao, 
          caption = "Resultado da Verifica√ß√£o de C√≥digos",
          options = list(
            pageLength = 10,
            dom = 't',  # mostra apenas a tabela
            ordering = FALSE
          )) %>%
  formatStyle("status",
              backgroundColor = styleEqual(c("‚úÖ", "‚ö†Ô∏è"), 
                                         c("#d4edda", "#fff3cd")))
```

### Interpreta√ß√£o dos Resultados

-   **Total**: Quantidade de c√≥digos √∫nicos encontrados nos dados
-   **Encontrados**: Quantos c√≥digos s√£o v√°lidos (existem nas refer√™ncias)\
-   **Perdidos**: Quantos c√≥digos s√£o inv√°lidos (n√£o existem nas refer√™ncias)
-   **Percentual**: Taxa de sucesso da valida√ß√£o
-   **Status**: ‚úÖ = Excelente (‚â•99% v√°lidos), ‚ö†Ô∏è = Aten√ß√£o (\<99% v√°lidos)

## Resumo de Problemas por Posi√ß√£o

```{r problemas_posicao}
# Conta quantos registros t√™m problemas em cada posi√ß√£o
resumo_problemas <- tabelao_validado %>% 
  select(starts_with("posicao_")) %>%
  summarise(across(everything(), ~ sum(.x == "verificar", na.rm = TRUE))) %>%
  # Reorganiza os dados para melhor visualiza√ß√£o
  pivot_longer(everything(), names_to = "Posi√ß√£o", values_to = "Problemas") %>%
  mutate(
    Posi√ß√£o = str_replace(Posi√ß√£o, "posicao_", "Posi√ß√£o "),
    `% Total` = round(Problemas / nrow(tabelao_validado) * 100, 3)
  )

datatable(resumo_problemas,
          rownames = FALSE,
          caption = "Problemas Identificados por Posi√ß√£o",
          options = list(
            pageLength = 6,
            dom = 't',
            ordering = FALSE
          )) %>%
  formatStyle("Problemas",
              backgroundColor = styleInterval(c(0, 1), 
                                            c("#d4edda", "#fff3cd", "#f8d7da")))
```

## Status Geral do Sistema

```{r status_geral}
# Calcula m√©tricas gerais do sistema
total_registros <- nrow(tabelao_validado)
registros_com_problema <- tabelao_validado %>%
  filter(if_any(starts_with("posicao_"), ~ .x == "verificar")) %>%
  nrow()

taxa_sucesso <- round((total_registros - registros_com_problema) / total_registros * 100, 2)

# Cria resumo visual
status_sistema <- data.frame(
  M√©trica = c("Total de Registros", "Registros V√°lidos", "Registros com Problemas", "Taxa de Sucesso"),
  Valor = c(
    format(total_registros, big.mark = "."),
    format(total_registros - registros_com_problema, big.mark = "."),
    format(registros_com_problema, big.mark = "."),
    paste0(taxa_sucesso, "%")
  ),
  Status = c("üìä", "‚úÖ", "‚ö†Ô∏è", if(taxa_sucesso >= 95) "üèÜ" else "üìà")
)

datatable(status_sistema,
          caption = "Status Geral do Sistema de Valida√ß√£o",
          options = list(
            pageLength = 4,
            dom = 't',
            ordering = FALSE
          ),
          rownames = FALSE) %>%
  formatStyle("Status", textAlign = "center")
```

# An√°lise Detalhada

## Distribui√ß√£o dos Tipos por Posi√ß√£o

```{r analise_detalhada}
# Cria visualiza√ß√£o da estrutura dos dados
analise_estrutura <- tibble(
  Posi√ß√£o = 1:6,
  `Tipos Encontrados` = c(
    paste(tipos_encontrados$pos_1, collapse = ", "),
    paste(tipos_encontrados$pos_2, collapse = ", "),
    paste(tipos_encontrados$pos_3, collapse = ", "),
    paste(tipos_encontrados$pos_4, collapse = ", "),
    paste(tipos_encontrados$pos_5, collapse = ", "),
    paste(tipos_encontrados$pos_6, collapse = ", ")
  ),
  `Descri√ß√£o` = c(
    "Programa Or√ßament√°rio",
    "Fun√ß√£o Program√°tica / Fonte de Recursos", 
    "Fonte de Recursos / Natureza Despesa / Natureza Receita",
    "Fun√ß√£o Subfun√ß√£o",
    "Ano de Inclus√£o / Complemento",
    "Complemento"
  )
)

datatable(analise_estrutura,
          caption = "Estrutura Detalhada dos Dados MSC",
          options = list(
            pageLength = 6,
            dom = 't',
            ordering = FALSE,
            columnDefs = list(list(width = '200px', targets = 1))
          ),
          rownames = FALSE)
```

# Batimento dos Saldo

## Saldos credores e devedores

```{r msc_credor_devedor}
# =============================================================================
# BATIMENTO DE SALDOS - MSC DATA VALIDATION PROJECT
# Valida√ß√£o e Concilia√ß√£o para Relat√≥rios Fiscais (RREO/RGF)
# =============================================================================

# -----------------------------------------------------------------------------
# 1. APLICA√á√ÉO DE REGRAS CONT√ÅBEIS E C√ÅLCULO DE SALDOS
# -----------------------------------------------------------------------------

# Aplicar regras de invers√£o de saldo conforme natureza cont√°bil
# Regra de neg√≥cio: Invers√£o de sinal conforme classe da conta e natureza
tabelao <- tabelao %>%
  mutate(
    saldo = case_when(
      # Contas de classes √≠mpares (1,3,5,7) com natureza 'C' - inverte sinal
      substr(conta, 1, 1) %in% c("1", "3", "5", "7") & natureza_valor == "C" ~ -valor,
      
      # Contas de classes pares (2,4,6,8) com natureza 'D' - inverte sinal  
      substr(conta, 1, 1) %in% c("2", "4", "6", "8") & natureza_valor == "D" ~ -valor,
      
      # Demais casos - mant√©m valor original
      TRUE ~ valor
    )
  ) %>%
  # Extrair classe cont√°bil do primeiro d√≠gito da conta
  mutate(classe = str_sub(conta, start = 1L, end = 1L))

```

## Batimento dos saldos da MSC

```{r saldos_msc}
# -----------------------------------------------------------------------------
# 2. CONSOLIDA√á√ÉO DE SALDOS POR CLASSE (FONTE MSC)
# -----------------------------------------------------------------------------

# Agregar saldos por classe e tipo de valor para an√°lise
saldos_msc <- tabelao %>% 
  group_by(classe, tipo_valor) %>% 
  summarise(saldo = sum(saldo, na.rm = TRUE), .groups = 'drop') %>%
  pivot_wider(names_from = tipo_valor, values_from = saldo) %>%
  mutate(resultado = beginning_balance + period_change - ending_balance)

# Exibir tabela de saldos consolidados MSC
cat("=== SALDOS CONSOLIDADOS MSC POR CLASSE ===\n")
datatable(saldos_msc, 
          rownames = FALSE,
          options = list(scrollX = TRUE, pageLength = 8),
          colnames = c("Classe", "Saldo Inicial", "Movimenta√ß√£o", "Saldo Final", "Resultado")) %>%
  formatRound(c("beginning_balance", "period_change", "ending_balance", "resultado"), 
             digits = 2, mark = ".", dec.mark = ",")


```

## Dados do SIAFI e Tesouro Gerencial

```{r saldos_siafi_TG}
# -----------------------------------------------------------------------------
# 3. CARREGAMENTO DE DADOS DE REFER√äNCIA
# -----------------------------------------------------------------------------

# Carregar balancete SIAFI para compara√ß√£o
balancete_siafi <- read_excel("balancete_siafi.xlsx", range = "A1:D9") %>% 
  clean_names() %>%
  mutate(classe = str_sub(conta, 1L, 1L))

# Carregar balancete TG MSC para valida√ß√£o cruzada
balancete_tg_msc <- read_excel("balancete_tg_msc.xlsx") %>% 
  clean_names() %>% 
  rename(classe = 1) %>% 
  filter(mes_lancamento == mes) %>% 
  select(-mes_lancamento)


```

## Concilia√ß√£o entre MSC, Siafi e Tesouro Gerencial

```{r conciliacao_saldos_msc_siafi_tg}
# -----------------------------------------------------------------------------
# 4. AN√ÅLISE COMPARATIVA DE CONCILIA√á√ÉO
# -----------------------------------------------------------------------------

# Criar matriz de compara√ß√£o entre as tr√™s fontes
comparacao_saldos <- data.frame(
  classe = 1:8,
  saldo_msc = saldos_msc$ending_balance,
  saldo_siafi = balancete_siafi$saldo_atual,
  saldo_tg_msc = balancete_tg_msc$saldo_r_conta_contabil
) %>%
  mutate(
    # Calcular diferen√ßas entre fontes
    diff_msc_siafi = saldo_msc - saldo_siafi,
    diff_msc_tg = saldo_msc - saldo_tg_msc,
    diff_siafi_tg = saldo_siafi - saldo_tg_msc,
    
    # Validar toler√¢ncia de concilia√ß√£o (< R$ 20,00)
    diff_msc_siafi_ok = abs(diff_msc_siafi) < 20,
    diff_msc_tg_ok = abs(diff_msc_tg) < 20,
    diff_siafi_tg_ok = abs(diff_siafi_tg) < 20,
    
    # Status geral de concilia√ß√£o
    conciliacao_ok = diff_msc_siafi_ok & diff_msc_tg_ok & diff_siafi_tg_ok
    
  )


# -----------------------------------------------------------------------------
# 5. RELAT√ìRIO DE RESULTADOS DA CONCILIA√á√ÉO
# -----------------------------------------------------------------------------



# Identificar e reportar classes problem√°ticas
classes_problemas <- comparacao_saldos[!comparacao_saldos$conciliacao_ok, ]
if(nrow(classes_problemas) > 0) {
  cat("=== CLASSES COM DIVERG√äNCIAS SUPERIORES A R$ 20,00 ===\n")
  print(classes_problemas[, c("classe", "diff_msc_siafi", "diff_msc_tg", "diff_siafi_tg")])
  cat("\n")
}



# -----------------------------------------------------------------------------
# 6. DASHBOARD INTERATIVO DE RESULTADOS
# -----------------------------------------------------------------------------

# Exibir tabela interativa com formata√ß√£o adequada
cat("=== DASHBOARD DE CONCILIA√á√ÉO POR CLASSE ===\n")
datatable(comparacao_saldos, 
          rownames = FALSE,
          options = list(
            scrollX = TRUE, 
            pageLength = 8,
            columnDefs = list(
              list(className = 'dt-center', targets = 0),
              list(className = 'dt-right', targets = 1:6)
            )
          ),
          colnames = c("Classe", "Saldo MSC", "Saldo SIAFI", "Saldo TG MSC",
                      "Diff MSC-SIAFI", "Diff MSC-TG", "Diff SIAFI-TG",
                      "MSC-SIAFI ‚úì", "MSC-TG ‚úì", "SIAFI-TG ‚úì", "Status Geral")) %>%
  formatRound(columns = c("saldo_msc", "saldo_siafi", "saldo_tg_msc", 
                         "diff_msc_siafi", "diff_msc_tg", "diff_siafi_tg"), 
             digits = 2, mark = ".", dec.mark = ",") %>%
  formatStyle(columns = c("diff_msc_siafi", "diff_msc_tg", "diff_siafi_tg"),
              backgroundColor = styleInterval(c(-20, 20), c("#ffcccc", "#ccffcc", "#ffcccc"))) %>%
  formatStyle("conciliacao_ok",
              backgroundColor = styleEqual(c(TRUE, FALSE), c("#d4edda", "#f8d7da")))

# -----------------------------------------------------------------------------
# 7. VALIDA√á√ïES FINAIS E ALERTAS
# -----------------------------------------------------------------------------

# Alertas de qualidade dos dados
if(any(is.na(comparacao_saldos$saldo_msc))) {
  warning("‚ö†Ô∏è  Valores ausentes detectados nos saldos MSC")
}

if(any(is.na(comparacao_saldos$saldo_siafi))) {
  warning("‚ö†Ô∏è  Valores ausentes detectados nos saldos SIAFI")
}

if(any(is.na(comparacao_saldos$saldo_tg_msc))) {
  warning("‚ö†Ô∏è  Valores ausentes detectados nos saldos TG MSC")
}

if(sum(!comparacao_saldos$conciliacao_ok) > 2) {
  warning("üö® ATEN√á√ÉO: Mais de 2 classes com diverg√™ncias significativas. Revisar dados de origem.")
}

cat("=== PROCESSO DE CONCILIA√á√ÉO FINALIZADO ===\n")
cat("Data/Hora:", format(Sys.time(), "%d/%m/%Y %H:%M:%S"), "\n")
cat("Status: CONCLU√çDO COM", ifelse(sum(!comparacao_saldos$conciliacao_ok) == 0, "SUCESSO", "RESSALVAS"), "\n")

```

```{}
```

# Conclus√µes e Pr√≥ximos Passos

## Resumo dos Resultados

Com base na an√°lise realizada:

1.  **Sistema funcionando corretamente**: O processo de valida√ß√£o autom√°tica detectou e validou todos os tipos de c√≥digos presentes nos dados

2.  **Alta taxa de conformidade**: A maioria dos c√≥digos est√° em conformidade com as refer√™ncias oficiais

3.  **Estrutura dos dados identificada**: O sistema mapeou automaticamente como os c√≥digos est√£o distribu√≠dos nas 6 posi√ß√µes

4.  **Filtro de c√≥digos exclu√≠dos ativo**: Sistema rejeita automaticamente c√≥digos com situacao_siconfi = "E"

## Pr√≥ximas Melhorias

-   **Alertas autom√°ticos**: Implementar notifica√ß√µes quando c√≥digos inv√°lidos forem detectados
-   **Relat√≥rios mensais**: Automatizar a gera√ß√£o deste relat√≥rio para an√°lises peri√≥dicas\
-   **Dashboard interativo**: Criar visualiza√ß√µes em tempo real para acompanhamento cont√≠nuo
-   **Integra√ß√£o com outros sistemas**: Conectar com sistemas de origem dos dados para valida√ß√£o preventiva

------------------------------------------------------------------------

*Relat√≥rio gerado automaticamente em `r format(Sys.time(), '%d/%m/%Y √†s %H:%M')`*

```{r}
View(balancete_siafi)
```
