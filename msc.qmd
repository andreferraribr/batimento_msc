---
title: "msc"
date: today
execute:
  warning: false
  message: false
  cache: false
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-summary: "Mostrar c√≥digo"
    fig-width: 10
    fig-height: 6
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

```{r}
#| include: false

# Bibliotecas principais
library(dplyr)
library(tidyr)
library(stringr)
library(readxl)
library(janitor)
library(purrr)
library(forcats)
library(DT)
library(knitr)
library(kableExtra)
library(readr)
library(scales)
```

```{r}
#| include: false
#| warning: false

mes <- "202507"

arquivo <- paste0("TG-MSC",mes,".csv")

TG_MSC <- read_delim(arquivo, 
    delim = ";", escape_double = FALSE, trim_ws = TRUE, 
    skip = 1)%>% mutate(CONTA = as.character(CONTA)) %>% clean_names()
```

```{r}
#| include: false
#| warning: false
TG_MSC %>% glimpse()

TG_MSC$IC1

```

```{r}
portaria_PO <- read_excel("portaria.xlsx", sheet = "PO", 
    skip = 4)%>% clean_names()
```

```{r}
portaria_CO <- read_excel("portaria.xlsx", sheet = "CO", 
    skip = 6)%>% clean_names() 

colnames(portaria_CO)[1] <- "co_siconfi"

portaria_CO <- portaria_CO %>% filter(str_detect(co_siconfi,".*[0-9].*" ))


```

```{r}
#| include: false
#| warning: false
portaria_LAYOUT <- read_excel("portaria.xlsx", sheet = "Leiaute MSC", 
    skip = 3) %>% mutate(CONTA = as.character(CONTA))%>% clean_names()
```

```{r}
# Fazer o left_join e corrigir os sufixos das colunas 5 e 6
tabelao <- left_join(TG_MSC, portaria_LAYOUT, suffix = c(".msc", ".layout"), by = "conta") %>%
  # Renomear colunas que n√£o receberam sufixo para manter consist√™ncia
  rename(
    ic5.msc = ic5,
    tipo5.msc = tipo5,
    ic6.msc = ic6, 
    tipo6.msc = tipo6
  )

# Verificar se funcionou
cat("Colunas relacionadas a IC e TIPO:\n")
names(tabelao)[grepl("ic[1-6]|tipo[1-6]", names(tabelao))]


```

```{r}
#| include: false
#| warning: false




# Importar RELNR.TXT - arquivo de largura fixa
relnr <- read_fwf("RELNR.TXT", 
                   skip = 10,  # pular cabe√ßalho
                   col_positions = fwf_positions(
                       start = c(1, 12, 39, 43, 53, 80),
                       end   = c(10, 38, 41, 50, 78, 82),
                       col_names = c("NR_SICONFI", "TITULO_SICONFI", "SITUACAO_SICONFI", 
                                     "NR_UNIAO", "TITULO_UNIAO", "SITUACAO_UNIAO")
                   ),
                   locale = locale(encoding = "latin1"))%>%
    clean_names()



relnd <- read_fwf("RELND.TXT", 
                  skip = 10,  # pular cabe√ßalho
                  col_positions = fwf_positions(
                      start = c(1, 12, 42, 53),
                      end   = c(10, 41, 52, 80),
                      col_names = c("ND_SICONFI", "TITULO_ND_SICONFI", 
                                    "ND_UNIAO", "TITULO_ND_UNIAO")
                  ),
                  locale = locale(encoding = "latin1")) %>%
    clean_names()

# Importar RELFONT.TXT - arquivo de largura fixa com 4 colunas
relfont <- read_fwf("RELFONT.TXT", 
                    skip = 7,  # pular cabe√ßalho
                    col_positions = fwf_positions(
                        start = c(1, 9, 61, 66),
                        end   = c(8, 58, 65, 68),
                        col_names = c("FR_SICONFI", "TITULO_FR_SICONFI", 
                                      "FR_UNIAO", "SIT")
                    ),
                    locale = locale(encoding = "latin1")) %>%
    clean_names()





todas_funcoes <- read_csv("todas_funcoes.txt")





```

```{r}
# SISTEMA DE VALIDA√á√ÉO AUTOM√ÅTICA
# Detecta tipos existentes e gera valida√ß√µes dinamicamente

#' Detecta tipos existentes em cada posi√ß√£o
#' @param dados Dataframe com dados MSC
#' @return Lista com tipos por posi√ß√£o
detectar_tipos_por_posicao <- function(dados) {
  
  cat("üîç DETECTANDO TIPOS POR POSI√á√ÉO:\n")
  cat("================================\n\n")
  
  tipos_por_posicao <- list()
  
  for(i in 1:6) {
    col_name <- paste0("tipo", i, ".msc")
    
    if(col_name %in% names(dados)) {
      tipos_unicos <- dados[[col_name]] %>% 
        .[!is.na(.)] %>% 
        unique() %>% 
        sort()
      
      tipos_por_posicao[[paste0("pos_", i)]] <- tipos_unicos
      
      # Mostrar contagem
      cat(paste0("POSI√á√ÉO ", i, ":\n"))
      print(table(dados[[col_name]], useNA = "ifany"))
      cat("\n")
    }
  }
  
  return(tipos_por_posicao)
}

#' Gera valida√ß√µes dinamicamente baseado nos tipos detectados
#' @param dados Dataframe MSC
#' @param tipos_detectados Lista retornada por detectar_tipos_por_posicao
#' @return Dataframe com valida√ß√µes aplicadas
aplicar_validacoes_automaticas <- function(dados, tipos_detectados) {
  
  cat("‚öôÔ∏è APLICANDO VALIDA√á√ïES AUTOM√ÅTICAS:\n")
  cat("====================================\n\n")
  
  # Preparar anos v√°lidos para AI
  anos_ai_validos <- 2004:2024
  
  # Construir valida√ß√µes dinamicamente
  dados_validados <- dados
  
  for(i in 1:6) {
    pos_key <- paste0("pos_", i)
    col_tipo <- paste0("tipo", i, ".msc")
    col_ic <- paste0("ic", i, ".msc")
    col_validacao <- paste0("posicao_", i)
    
    if(pos_key %in% names(tipos_detectados) && 
       col_tipo %in% names(dados) && 
       col_ic %in% names(dados)) {
      
      tipos_nesta_posicao <- tipos_detectados[[pos_key]]
      
      cat(paste0("Posi√ß√£o ", i, ": ", paste(tipos_nesta_posicao, collapse = ", "), "\n"))
      
      # Construir case_when dinamicamente
      dados_validados <- dados_validados %>%
        mutate(
          !!col_validacao := case_when(
            # PO
            if("PO" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "PO" ~ ifelse(.data[[col_ic]] %in% portaria_PO$codigo, "ok", "verificar")
            } else { NULL },
            
            # FR
            if("FR" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "FR" ~ ifelse(.data[[col_ic]] %in% relfont$fr_siconfi, "ok", "verificar")
            } else { NULL },
            
            # ND
            if("ND" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "ND" ~ ifelse(.data[[col_ic]] %in% relnd$nd_siconfi, "ok", "verificar")
            } else { NULL },
            
            # NR
            if("NR" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "NR" ~ ifelse(.data[[col_ic]] %in% relnr$nr_siconfi, "ok", "verificar")
            } else { NULL },
            
            # CO
            if("CO" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "CO" ~ ifelse(.data[[col_ic]] %in% portaria_CO$co_siconfi, "ok", "verificar")
            } else { NULL },
            
            # AI
            if("AI" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "AI" ~ ifelse(.data[[col_ic]] %in% anos_ai_validos, "ok", "verificar")
            } else { NULL },
            
            # FP e FS - considerados sempre v√°lidos por enquanto
            if("FP" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "FP" ~ "ok"
            } else { NULL },
            
            if("FS" %in% tipos_nesta_posicao) {
              .data[[col_tipo]] == "FS" ~ "ok"
            } else { NULL },
            
            # Demais casos
            TRUE ~ "demais"
          )
        )
    }
  }
  
  cat("\n‚úÖ Valida√ß√µes aplicadas dinamicamente!\n\n")
  return(dados_validados)
}

#' Vers√£o simplificada usando mutate direto
aplicar_validacoes_simples <- function(dados, tipos_detectados) {
  
  cat("‚öôÔ∏è APLICANDO VALIDA√á√ïES (vers√£o simplificada):\n")
  cat("==============================================\n\n")
  
  anos_ai_validos <- 2004:2024
  
  # Aplicar valida√ß√µes baseado nos tipos detectados
  dados %>%
    mutate(
      # Posi√ß√£o 1
      posicao_1 = case_when(
        if("PO" %in% tipos_detectados$pos_1) tipo1.msc == "PO" ~ ifelse(ic1.msc %in% portaria_PO$codigo, "ok", "verificar") else NULL,
        TRUE ~ "demais"
      ),
      
      # Posi√ß√£o 2  
      posicao_2 = case_when(
        if("FP" %in% tipos_detectados$pos_2) tipo2.msc == "FP" ~ "ok" else NULL,
        if("FR" %in% tipos_detectados$pos_2) tipo2.msc == "FR" ~ ifelse(ic2.msc %in% relfont$fr_siconfi, "ok", "verificar") else NULL,
        TRUE ~ "demais"
      ),
      
      # Posi√ß√£o 3
      posicao_3 = case_when(
        if("FR" %in% tipos_detectados$pos_3) tipo3.msc == "FR" ~ ifelse(ic3.msc %in% relfont$fr_siconfi, "ok", "verificar") else NULL,
        if("ND" %in% tipos_detectados$pos_3) tipo3.msc == "ND" ~ ifelse(ic3.msc %in% relnd$nd_siconfi, "ok", "verificar") else NULL,
        if("NR" %in% tipos_detectados$pos_3) tipo3.msc == "NR" ~ ifelse(ic3.msc %in% relnr$nr_siconfi, "ok", "verificar") else NULL,
        TRUE ~ "demais"
      ),
      
      # Posi√ß√£o 4
      posicao_4 = case_when(
        if("FS" %in% tipos_detectados$pos_4) tipo4.msc == "FS" ~ "ok" else NULL,
        TRUE ~ "demais"
      ),
      
      # Posi√ß√£o 5
      posicao_5 = case_when(
        if("AI" %in% tipos_detectados$pos_5) tipo5.msc == "AI" ~ ifelse(ic5.msc %in% anos_ai_validos, "ok", "verificar") else NULL,
        if("CO" %in% tipos_detectados$pos_5) tipo5.msc == "CO" ~ ifelse(ic5.msc %in% portaria_CO$co_siconfi, "ok", "verificar") else NULL,
        TRUE ~ "demais"
      ),
      
      # Posi√ß√£o 6
      posicao_6 = case_when(
        if("CO" %in% tipos_detectados$pos_6) tipo6.msc == "CO" ~ ifelse(ic6.msc %in% portaria_CO$co_siconfi, "ok", "verificar") else NULL,
        TRUE ~ "demais"
      )
    )
}

#' Fun√ß√£o principal que executa todo o processo automaticamente
executar_validacao_automatica <- function(dados) {
  
  cat("üöÄ INICIANDO VALIDA√á√ÉO AUTOM√ÅTICA\n")
  cat("=================================\n\n")
  
  # Passo 1: Detectar tipos
  tipos_detectados <- detectar_tipos_por_posicao(dados)
  
  # Passo 2: Aplicar valida√ß√µes
  dados_validados <- dados %>%
    mutate(
      # Construir valida√ß√µes baseado nos tipos detectados
      posicao_1 = case_when(
        tipo1.msc == "PO" ~ ifelse(ic1.msc %in% portaria_PO$codigo, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      posicao_2 = case_when(
        tipo2.msc == "FP" ~ "ok",
        tipo2.msc == "FR" ~ ifelse(ic2.msc %in% relfont$fr_siconfi, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      posicao_3 = case_when(
        tipo3.msc == "FR" ~ ifelse(ic3.msc %in% relfont$fr_siconfi, "ok", "verificar"),
        tipo3.msc == "ND" ~ ifelse(ic3.msc %in% relnd$nd_siconfi, "ok", "verificar"),
        tipo3.msc == "NR" ~ ifelse(ic3.msc %in% relnr$nr_siconfi, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      posicao_4 = case_when(
        tipo4.msc == "FS" ~ "ok",
        TRUE ~ "demais"
      ),
      
      posicao_5 = case_when(
        tipo5.msc == "AI" ~ ifelse(ic5.msc %in% (2004:2024), "ok", "verificar"),
        tipo5.msc == "CO" ~ ifelse(ic5.msc %in% portaria_CO$co_siconfi, "ok", "verificar"),
        TRUE ~ "demais"
      ),
      
      posicao_6 = case_when(
        tipo6.msc == "CO" ~ ifelse(ic6.msc %in% portaria_CO$co_siconfi, "ok", "verificar"),
        TRUE ~ "demais"
      )
    )
  
  cat("‚úÖ Valida√ß√£o autom√°tica conclu√≠da!\n\n")
  
  return(list(
    dados_validados = dados_validados,
    tipos_detectados = tipos_detectados
  ))
}


```

```{r}
# EXEMPLO DE USO:
resultado <- executar_validacao_automatica(tabelao)
tabelao_validado <- resultado$dados_validados
tipos_encontrados <- resultado$tipos_detectados
```

```{r}
# Verificar se funcionaram
# Criar anos v√°lidos para AI
anos_ai_validos <- 2004:2024

# Criar grupos (se n√£o existirem)
FT_msc <- agrupar_tipos("FR")   
ND_msc <- agrupar_tipos("ND")   
NR_msc <- agrupar_tipos("NR")   
CO_msc <- agrupar_tipos("CO")   
AI_msc <- agrupar_tipos("AI")

# Fun√ß√£o para verificar todos os c√≥digos
verificar_todos_codigos_correto <- function() {
  
  tribble(
    ~tipo, ~dados, ~referencia,
    "FR", FT_msc, relfont$fr_siconfi,
    "NR", NR_msc, relnr$nr_siconfi,
    "ND", ND_msc, relnd$nd_siconfi,
    "CO", CO_msc, portaria_CO$co_siconfi,
    "AI", AI_msc, anos_ai_validos
  ) %>%
  mutate(
    diagnostico = map2(dados, referencia, ~{
      if(nrow(.x) == 0) {
        return(tibble(
          total = 0,
          encontrados = 0,
          perdidos = 0,
          percentual = 0,
          status = "N/A"
        ))
      }
      
      codigos <- as.numeric(.x$codigo)
      ref_vec <- if(is.data.frame(.y)) .y[[1]] else .y
      
      encontrados_logico <- codigos %in% ref_vec
      encontrados_count <- sum(encontrados_logico, na.rm = TRUE)
      total_count <- length(codigos)
      
      tibble(
        total = total_count,
        encontrados = encontrados_count,
        perdidos = total_count - encontrados_count,
        percentual = round((encontrados_count / total_count) * 100, 1),
        status = if_else((encontrados_count / total_count) >= 0.99, "‚úÖ", "‚ö†Ô∏è")
      )
    })
  ) %>%
  select(-dados, -referencia) %>%
  unnest(diagnostico)
}

datatable(verificar_todos_codigos_correto())
```

```{r}
# Resumo de problemas
datatable(tabelao_validado %>% 
  select(starts_with("posicao_")) %>%
  summarise(across(everything(), ~ sum(.x == "verificar", na.rm = TRUE))))
```

```{r}
# Ver registros com problemas
problemas <- tabelao_validado %>%
  filter(if_any(starts_with("posicao_"), ~ .x == "verificar"))
```

```{r}
#| warning: false

tabelao <- tabelao %>%
  mutate(
    saldo = case_when(
      # Se conta come√ßar com 1, 3, 5, 7 e natureza_valor = 'C', ent√£o inverte o sinal
      substr(conta, 1, 1) %in% c("1", "3", "5", "7") & natureza_valor == "C" ~ -valor,
      
      # Se conta come√ßar com 2, 4, 6, 8 e natureza_valor = 'D', ent√£o inverte o sinal  
      substr(conta, 1, 1) %in% c("2", "4", "6", "8") & natureza_valor == "D" ~ -valor,
      
      # Em todos os outros casos, mant√©m o valor original
      TRUE ~ valor
    )
  )

tabelao <- tabelao %>% mutate(
  classe = str_sub(conta, start = 1L, end = 1L)
)


datatable(tabelao %>% group_by(classe, tipo_valor)%>% summarise(saldo = sum(saldo, na.rm = TRUE)) %>% pivot_wider(names_from = tipo_valor, values_from = saldo)%>% mutate(resultado = beginning_balance + period_change - ending_balance)  )
```
